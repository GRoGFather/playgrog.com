<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GRoG — Something is Brewing</title>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    html, body { width: 100%; height: 100%; }

    body {
      min-height: 100vh;
      min-height: 100dvh;
      background: #0a0e1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Palatino Linotype', Palatino, 'Book Antiqua', Georgia, serif;
      overflow: hidden;
    }

    /* ── PARTICLE CANVAS ── */
    #bg {
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
    }

    /* ── ROOM BACKGROUND (easter egg) ── */
    #room-bg {
      position: fixed;
      inset: 0;
      z-index: 1;
      background-image: url('bg_hd.png');
      background-size: cover;
      background-position: center center;
      opacity: 0;
      transition: opacity 2.8s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }
    #room-bg.visible { opacity: 0.82; }

    /* ── VIGNETTE ── */
    .vignette {
      position: fixed;
      inset: 0;
      z-index: 2;
      background: radial-gradient(ellipse 82% 78% at 50% 42%,
        transparent 0%,
        rgba(5,8,20,0.55) 65%,
        rgba(3,5,14,0.90) 100%);
      pointer-events: none;
      transition: opacity 2.8s ease;
    }
    .vignette.dimmed { opacity: 0.45; }

    /* ── SCENE ── */
    .scene {
      position: relative;
      z-index: 3;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      text-align: center;
      padding: 2rem 1.5rem;
    }

    /* ── MUG ── */
    .mug-wrap {
      position: relative;
      filter:
        drop-shadow(0 0 20px rgba(42,157,92,0.50))
        drop-shadow(0 0 60px rgba(42,157,92,0.20))
        drop-shadow(0 14px 40px rgba(0,0,0,0.70));
      animation: mugFloat 6s ease-in-out infinite, glowPulse 4s ease-in-out infinite;
      transition: filter 0.4s ease;
    }
    .mug-wrap svg {
      width: min(195px, 54vw);
      height: auto;
      display: block;
      overflow: visible;
    }

    @keyframes mugFloat {
      0%, 100% { transform: translateY(0px);  }
      50%       { transform: translateY(-11px); }
    }
    @keyframes glowPulse {
      0%, 100% {
        filter:
          drop-shadow(0 0 20px rgba(42,157,92,0.50))
          drop-shadow(0 0 60px rgba(42,157,92,0.20))
          drop-shadow(0 14px 40px rgba(0,0,0,0.70));
      }
      50% {
        filter:
          drop-shadow(0 0 28px rgba(42,157,92,0.68))
          drop-shadow(0 0 80px rgba(42,157,92,0.30))
          drop-shadow(0 14px 40px rgba(0,0,0,0.70));
      }
    }
    /* Flash on unlock */
    .mug-wrap.flash {
      animation: mugFloat 6s ease-in-out infinite, glowFlash 0.6s ease forwards;
    }
    @keyframes glowFlash {
      0%   { filter: drop-shadow(0 0 60px rgba(42,157,92,1.0)) drop-shadow(0 0 120px rgba(42,157,92,0.6)); }
      100% { filter: drop-shadow(0 0 20px rgba(42,157,92,0.50)) drop-shadow(0 0 60px rgba(42,157,92,0.20)) drop-shadow(0 14px 40px rgba(0,0,0,0.70)); }
    }

    /* Steam */
    @keyframes steamUp {
      0%   { opacity: 0;    transform: translateY(0px)   scaleX(1.0); }
      18%  { opacity: 0.72;                                            }
      65%  { opacity: 0.28;                                            }
      100% { opacity: 0;    transform: translateY(-58px) scaleX(2.2); }
    }
    .steam { animation: steamUp 3.4s ease-out infinite; transform-box: fill-box; transform-origin: bottom center; }
    .s1 { animation-delay: 0s;    }
    .s2 { animation-delay: 1.1s;  }
    .s3 { animation-delay: 2.25s; }

    /* Bubbles */
    @keyframes bubbleRise {
      0%   { transform: translateY(0px)    translateX(0px);   opacity: 0.88; }
      28%  { transform: translateY(-42px)  translateX(4px);                  }
      62%  { transform: translateY(-90px)  translateX(-3px);  opacity: 0.52; }
      100% { transform: translateY(-155px) translateX(2px);   opacity: 0;    }
    }
    .gb { animation: bubbleRise linear infinite; }
    .gb1 { animation-duration: 2.5s;  animation-delay: 0s;    }
    .gb2 { animation-duration: 3.2s;  animation-delay: 0.72s; }
    .gb3 { animation-duration: 2.85s; animation-delay: 1.44s; }
    .gb4 { animation-duration: 3.55s; animation-delay: 0.38s; }
    .gb5 { animation-duration: 2.35s; animation-delay: 1.15s; }
    .gb6 { animation-duration: 3.05s; animation-delay: 1.92s; }

    /* Surface shimmer */
    @keyframes shimmer {
      0%, 100% { opacity: 0.18; }
      50%       { opacity: 0.55; }
    }
    .sh  { animation: shimmer 2.8s ease-in-out infinite; transform-box: fill-box; }
    .sh2 { animation: shimmer 2.8s ease-in-out infinite 1.4s; transform-box: fill-box; }

    /* ── TYPOGRAPHY ── */
    .wordmark {
      font-size: clamp(1.8rem, 6.5vw, 4rem);
      color: #d4a843;
      letter-spacing: 0.23em;
      line-height: 1;
      text-shadow:
        0 0 28px rgba(212,168,67,0.70),
        0 0 70px rgba(212,168,67,0.28),
        0 3px 10px rgba(0,0,0,0.55);
      opacity: 0;
      animation: riseIn 1.6s cubic-bezier(0.16,1,0.3,1) 0.4s forwards;
    }

    .tagline {
      font-size: clamp(0.88rem, 2.3vw, 1.15rem);
      color: #a89b88;
      font-style: italic;
      letter-spacing: 0.04em;
      opacity: 0;
      animation: fadeIn 2.5s ease 2s forwards;
      margin-top: 0.2rem;
    }

    @keyframes riseIn {
      from { opacity: 0; transform: translateY(24px); }
      to   { opacity: 1; transform: translateY(0);    }
    }
    @keyframes fadeIn {
      from { opacity: 0;    }
      to   { opacity: 0.68; }
    }

    /* ── BINOCULAR MODE ── */
    body.peeking { cursor: none; }
    body.peeking .scene { opacity: 0; transition: opacity 0.6s ease; }

    /* ── LENS CANVAS (easter egg) ── */
    #lens {
      position: fixed;
      z-index: 20;
      pointer-events: none;
      background: transparent;
      /* drop-shadow follows the actual painted circles, not the canvas rect */
      filter:
        drop-shadow(0 8px 35px rgba(0,0,0,0.90))
        drop-shadow(0 0 18px rgba(0,0,0,0.60));
      opacity: 0;
      transition: opacity 0.25s ease;
      display: none;
    }
  </style>
</head>
<body>

<!--
  Hey. You opened the source.
  We like you already.
  Type what you came for.
-->

<!-- Particles -->
<canvas id="bg"></canvas>

<!-- Room background (easter egg reveal) -->
<div id="room-bg"></div>

<!-- Vignette -->
<div class="vignette" id="vignette"></div>

<!-- Main scene -->
<main class="scene">

  <!-- ═══════════════════════════ GROG MUG ═══════════════════════════ -->
  <div class="mug-wrap" id="mug">
    <svg viewBox="0 0 200 268" xmlns="http://www.w3.org/2000/svg"
         style="overflow:visible" aria-hidden="true">
      <defs>
        <linearGradient id="gG" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%"   stop-color="#1a5c3a"/>
          <stop offset="42%"  stop-color="#27935a"/>
          <stop offset="100%" stop-color="#0c3622"/>
        </linearGradient>
        <linearGradient id="mB" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%"   stop-color="#22140a"/>
          <stop offset="14%"  stop-color="#533319"/>
          <stop offset="48%"  stop-color="#6a441f"/>
          <stop offset="83%"  stop-color="#412a11"/>
          <stop offset="100%" stop-color="#1b0f07"/>
        </linearGradient>
        <linearGradient id="mR" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%"   stop-color="#a0804a"/>
          <stop offset="38%"  stop-color="#6e5127"/>
          <stop offset="100%" stop-color="#3a2610"/>
        </linearGradient>
        <linearGradient id="mH" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%"   stop-color="#3e2812"/>
          <stop offset="50%"  stop-color="#56391a"/>
          <stop offset="100%" stop-color="#2b1d0a"/>
        </linearGradient>
        <clipPath id="mI">
          <path d="M 52,88 L 148,88 L 140,228 L 60,228 Z"/>
        </clipPath>
        <filter id="gl" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="2.8" result="b"/>
          <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
      </defs>

      <!-- Steam -->
      <path class="steam s1" d="M 70,74 C 64,61 74,50 67,36 C 60,22 70,10 64,1"
        fill="none" stroke="rgba(215,238,228,0.58)" stroke-width="3.5" stroke-linecap="round"/>
      <path class="steam s2" d="M 100,71 C 107,58 97,46 104,32 C 111,18 101,7 107,-1"
        fill="none" stroke="rgba(215,238,228,0.50)" stroke-width="3.0" stroke-linecap="round"/>
      <path class="steam s3" d="M 130,74 C 136,61 126,50 133,36 C 140,22 130,10 136,1"
        fill="none" stroke="rgba(215,238,228,0.54)" stroke-width="3.5" stroke-linecap="round"/>

      <!-- Mug body -->
      <path d="M 43,84 L 157,84 L 147,231 L 53,231 Z" fill="url(#mB)"/>

      <!-- Liquid (clipped) -->
      <g clip-path="url(#mI)">
        <rect x="40" y="88" width="120" height="145" fill="url(#gG)"/>
        <ellipse cx="100" cy="208" rx="52" ry="17" fill="rgba(42,157,92,0.22)"/>
        <path d="M 68,212 Q 84,204 100,212 Q 116,220 132,212"
              fill="none" stroke="rgba(80,210,130,0.18)" stroke-width="2.5"/>
        <ellipse cx="100" cy="90" rx="44" ry="5.5" fill="rgba(195,248,218,0.22)"/>
        <ellipse cx="84"  cy="89" rx="19" ry="3.2" fill="rgba(225,255,238,0.28)"/>
        <ellipse cx="118" cy="89" rx="15" ry="2.8" fill="rgba(225,255,238,0.22)"/>
        <ellipse class="sh"  cx="86"  cy="90" rx="26" ry="1.8" fill="rgba(255,255,255,0.28)"/>
        <ellipse class="sh2" cx="116" cy="90" rx="18" ry="1.5" fill="rgba(255,255,255,0.22)"/>
        <circle class="gb gb1" cx="73"  cy="202" r="4.5" fill="rgba(82,225,142,0.80)" filter="url(#gl)"/>
        <circle class="gb gb2" cx="108" cy="218" r="3.2" fill="rgba(70,212,132,0.74)"/>
        <circle class="gb gb3" cx="133" cy="200" r="5.2" fill="rgba(62,202,122,0.72)" filter="url(#gl)"/>
        <circle class="gb gb4" cx="88"  cy="222" r="2.8" fill="rgba(102,238,162,0.84)"/>
        <circle class="gb gb5" cx="120" cy="210" r="3.8" fill="rgba(76,218,138,0.77)"/>
        <circle class="gb gb6" cx="80"  cy="215" r="2.2" fill="rgba(92,232,152,0.82)"/>
      </g>

      <!-- Grog surface at rim -->
      <ellipse cx="100" cy="85"  rx="53" ry="10"  fill="#1c6840" opacity="0.96"/>
      <ellipse cx="100" cy="84"  rx="44" ry="6.5" fill="#2ea860" opacity="0.88"/>
      <ellipse cx="100" cy="83"  rx="33" ry="4"   fill="#3dbe76" opacity="0.78"/>
      <ellipse cx="80"  cy="80"  rx="9"  ry="2.5" fill="rgba(192,248,215,0.48)"/>
      <ellipse cx="113" cy="81"  rx="14" ry="3.2" fill="rgba(192,248,215,0.42)"/>
      <ellipse cx="100" cy="79"  rx="7"  ry="2.0" fill="rgba(235,255,243,0.52)"/>
      <ellipse cx="91"  cy="78"  rx="4"  ry="1.4" fill="rgba(245,255,248,0.58)"/>

      <!-- Rim -->
      <path d="M 37,71 L 163,71 L 155,86 L 45,86 Z" fill="url(#mR)"/>
      <line x1="38" y1="71" x2="162" y2="71" stroke="rgba(205,170,95,0.72)" stroke-width="1.5"/>
      <path d="M 49,83 L 151,83 L 149,87 L 51,87 Z" fill="rgba(0,0,0,0.42)"/>

      <!-- Bands & rivets -->
      <rect x="43" y="107" width="114" height="6"   rx="1" fill="rgba(28,18,7,0.72)"/>
      <rect x="45" y="155" width="110" height="8"   rx="1" fill="rgba(28,18,7,0.78)"/>
      <circle cx="59"  cy="159" r="3.2" fill="#694820"/><circle cx="59"  cy="159" r="1.6" fill="#8d6435"/>
      <circle cx="100" cy="159" r="3.2" fill="#694820"/><circle cx="100" cy="159" r="1.6" fill="#8d6435"/>
      <circle cx="141" cy="159" r="3.2" fill="#694820"/><circle cx="141" cy="159" r="1.6" fill="#8d6435"/>
      <rect x="47" y="202" width="106" height="5.5" rx="1" fill="rgba(28,18,7,0.65)"/>

      <!-- Body shading -->
      <path d="M 47,91 L 57,229" stroke="rgba(165,125,60,0.22)" stroke-width="8" stroke-linecap="round"/>
      <path d="M 153,91 L 143,229" stroke="rgba(0,0,0,0.38)" stroke-width="7" stroke-linecap="round"/>
      <path d="M 46,122 L 154,119" stroke="rgba(255,200,110,0.04)" stroke-width="2"/>
      <path d="M 47,140 L 153,137" stroke="rgba(0,0,0,0.05)"       stroke-width="1.5"/>
      <path d="M 47,178 L 153,175" stroke="rgba(255,200,110,0.04)" stroke-width="2"/>
      <path d="M 78,86 L 76,97 Q 75,104 78,104 Q 81,104 80,97 Z" fill="rgba(42,157,92,0.65)"/>
      <path d="M 53,88 L 147,88 L 139,227 L 61,227 Z" fill="none" stroke="rgba(42,157,92,0.14)" stroke-width="5"/>

      <!-- Handle -->
      <path d="M 151,113 C 196,113 196,212 151,212 L 148,203 C 184,203 184,121 148,121 Z" fill="url(#mH)"/>
      <path d="M 150,124 C 174,124 174,200 150,200 L 149,194 C 168,194 168,130 149,130 Z" fill="#0a0e1a" opacity="0.74"/>
      <path d="M 153,116 C 191,117 191,208 153,208" fill="none" stroke="rgba(145,105,48,0.38)" stroke-width="2"/>

      <!-- Base -->
      <path d="M 51,229 L 149,229 L 155,244 L 45,244 Z" fill="#2c1d0a"/>
      <path d="M 43,242 L 157,242 L 159,253 L 41,253 Z" fill="#190f06"/>
      <line x1="45" y1="242" x2="155" y2="242" stroke="rgba(105,75,35,0.45)" stroke-width="1"/>
    </svg>
  </div>

  <h1 class="wordmark">GRoG</h1>
  <p class="tagline">Something is brewing&hellip;</p>

</main>

<!-- Lens (easter egg) -->
<canvas id="lens"></canvas>

<script>
/* ══════════════════════════════════════════
   PARTICLE SYSTEM
══════════════════════════════════════════ */
(function () {
  'use strict';
  const canvas = document.getElementById('bg');
  const ctx    = canvas.getContext('2d');
  let W = 0, H = 0;

  function onResize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
  window.addEventListener('resize', onResize, { passive: true });
  onResize();

  const TYPES = [
    { type: 'bubble',  cr: 62,  cg: 200, cb: 110 },
    { type: 'bubble',  cr: 42,  cg: 168, cb: 90  },
    { type: 'bubble',  cr: 82,  cg: 232, cb: 142 },
    { type: 'sparkle', cr: 212, cg: 168, cb: 67  },
    { type: 'sparkle', cr: 180, cg: 140, cb: 55  },
    { type: 'mist',    cr: 155, cg: 208, cb: 182 },
  ];

  class Particle {
    constructor(pre) { this.init(pre); }
    init(pre) {
      const t = TYPES[Math.floor(Math.random() * TYPES.length)];
      this.type = t.type; this.cr = t.cr; this.cg = t.cg; this.cb = t.cb;
      this.x = Math.random() * (W || 800);
      this.y = pre ? Math.random() * (H || 600) : (H || 600) + 10;
      this.sz = Math.random() * 2.4 + 0.5;
      this.vy = -(Math.random() * 0.44 + 0.10);
      this.vx = (Math.random() - 0.5) * 0.24;
      this.peak = Math.random() * 0.33 + 0.04;
      this.maxAge = Math.random() * 390 + 160;
      this.age = pre ? Math.random() * this.maxAge : 0;
      this.ang = Math.random() * Math.PI * 2;
    }
    tick() {
      this.age++; this.ang += 0.027;
      this.x += this.vx + Math.sin(this.ang) * 0.17;
      this.y += this.vy;
      const t = this.age / this.maxAge;
      this.a = t < 0.10 ? this.peak * (t / 0.10) : t > 0.78 ? this.peak * ((1-t)/0.22) : this.peak;
      if (this.age >= this.maxAge || this.y < -12) this.init(false);
    }
    draw() {
      const { cr, cg, cb } = this;
      ctx.save(); ctx.globalAlpha = this.a;
      if (this.type === 'bubble') {
        ctx.beginPath(); ctx.arc(this.x, this.y, this.sz, 0, Math.PI*2);
        ctx.strokeStyle = `rgb(${cr},${cg},${cb})`; ctx.lineWidth = 0.9; ctx.stroke();
        ctx.fillStyle = `rgba(${cr},${cg},${cb},0.20)`; ctx.fill();
      } else if (this.type === 'sparkle') {
        ctx.translate(this.x, this.y); ctx.rotate(this.ang * 1.6);
        const s = this.sz * 2.1;
        ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
        ctx.beginPath();
        ctx.moveTo(0, -s*2.6); ctx.lineTo(s*0.58, 0); ctx.lineTo(0, s*2.6); ctx.lineTo(-s*0.58, 0);
        ctx.closePath(); ctx.fill();
      } else {
        ctx.beginPath(); ctx.arc(this.x, this.y, this.sz*2.4, 0, Math.PI*2);
        ctx.fillStyle = `rgba(${cr},${cg},${cb},0.26)`; ctx.fill();
      }
      ctx.restore();
    }
  }

  const particles = Array.from({ length: 68 }, () => new Particle(true));
  function frame() { ctx.clearRect(0,0,W,H); particles.forEach(p => { p.tick(); p.draw(); }); requestAnimationFrame(frame); }
  frame();
})();


/* ══════════════════════════════════════════
   EASTER EGG — type GROG to reveal
══════════════════════════════════════════ */
(function () {
  'use strict';

  const CODE       = ['f','i','n','e','l','e','a','t','h','e','r','j','a','c','k','e','t','s'];
  const FADE_MS    = 2800;   // must match CSS transition on #room-bg / .vignette

  let seq          = 0;
  let active       = false;
  let lensReady    = false;  // images loaded?
  let lensEnabled  = false;  // currently revealed?
  let lensVisible  = false;  // cursor on screen?

  /* ── Keyboard listener ── */
  document.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === CODE[seq]) {
      seq++;
      if (seq === CODE.length) {
        seq = 0;
        if (!active) { active = true; unlock(); }
      }
    } else {
      seq = (k === CODE[0]) ? 1 : 0;
    }
  });

  /* ── Unlock ── */
  function unlock() {
    // Mug flash
    const mug = document.getElementById('mug');
    mug.classList.add('flash');
    setTimeout(() => mug.classList.remove('flash'), 700);

    // Reveal room & lighten vignette
    document.getElementById('room-bg').classList.add('visible');
    document.getElementById('vignette').classList.add('dimmed');

    // Magnifying glass cursor
    document.body.classList.add('peeking');

    // Enable lens (images may or may not be loaded yet)
    lensEnabled = true;
    if (lensReady) {
      document.getElementById('lens').style.display = 'block';
    } else {
      loadLens();
    }

    // Click anywhere to close
    document.addEventListener('click', revert, { once: true });
  }

  /* ── Revert ── */
  function revert() {
    lensEnabled  = false;
    lensVisible  = false;

    // Restore default cursor
    document.body.classList.remove('peeking');

    // Fade out lens immediately
    const lens = document.getElementById('lens');
    lens.style.opacity = '0';
    setTimeout(() => { lens.style.display = 'none'; }, 300);

    // Fade background and vignette back
    document.getElementById('room-bg').classList.remove('visible');
    document.getElementById('vignette').classList.remove('dimmed');

    // Allow re-triggering once the CSS fade is complete
    setTimeout(() => { active = false; }, FADE_MS);
  }

  /* ── Lens image loading ── */
  function loadLens() {
    const origImg = new Image();
    const hdImg   = new Image();
    let loaded = 0;
    const onLoad = () => {
      if (++loaded === 2) {
        lensReady = true;
        setupLens(origImg, hdImg);
      }
    };
    origImg.onload = hdImg.onload = onLoad;
    origImg.onerror = hdImg.onerror = () => console.warn('GRoG: lens image failed to load');
    origImg.src = 'bg_orig.png';
    hdImg.src   = 'bg_hd.png';
  }

  function setupLens(origImg, hdImg) {
    const lens  = document.getElementById('lens');
    const ctx   = lens.getContext('2d');
    const vpW   = () => window.innerWidth;
    const vpH   = () => window.innerHeight;

    // Only show if we're still in the peek window
    if (lensEnabled) lens.style.display = 'block';

    // Layout: [big SD] [small reticle] [big HD]
    // Cursor is locked to centre of the small reticle circle
    const S = 80;   // reticle diameter (px) — fixed

    function lensShape() {
      const d = Math.min(320, Math.floor((window.innerWidth - S - 40) / 2));
      return { d, lw: d * 2 + S, lh: d };
    }

    // Source image dimensions
    const ORIG_W = 640, ORIG_H = 480;
    const HD_W   = hdImg.naturalWidth  || 1440;
    const HD_SCL = HD_W / ORIG_W;  // 2.25

    function draw(mx, my) {
      const { d, lw, lh } = lensShape();
      if (lens.width !== lw || lens.height !== lh) { lens.width = lw; lens.height = lh; }

      // Cover-fit: map cursor to original image coords
      const vw = vpW(), vh = vpH();
      const bgScale = Math.max(vw / ORIG_W, vh / ORIG_H);
      const bgOX    = (vw - ORIG_W * bgScale) / 2;
      const bgOY    = (vh - ORIG_H * bgScale) / 2;

      // Sample region = what the reticle circle covers in original-image pixels
      const SAMP = S / bgScale;
      const hs   = SAMP / 2;
      const ix   = Math.max(hs, Math.min(ORIG_W - hs, (mx - bgOX) / bgScale));
      const iy   = Math.max(hs, Math.min(ORIG_H - hs, (my - bgOY) / bgScale));

      ctx.clearRect(0, 0, lw, lh);

      // ── Left big circle: SD original (pixelated) ──
      ctx.save();
      ctx.beginPath();
      ctx.arc(d / 2, d / 2, d / 2, 0, Math.PI * 2);
      ctx.clip();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(origImg, ix - hs, iy - hs, SAMP, SAMP, 0, 0, d, d);
      ctx.restore();

      // ── Right big circle: HD (smooth) ──
      const rx = d + S;   // left edge of right circle
      ctx.save();
      ctx.beginPath();
      ctx.arc(rx + d / 2, d / 2, d / 2, 0, Math.PI * 2);
      ctx.clip();
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(hdImg,
        (ix - hs) * HD_SCL, (iy - hs) * HD_SCL, SAMP * HD_SCL, SAMP * HD_SCL,
        rx, 0, d, d);
      ctx.restore();

      // ── Small reticle circle (centre) ──
      const cx = d + S / 2, cy = d / 2, cr = S / 2 - 1;

      // Vignette ring inside reticle
      const grad = ctx.createRadialGradient(cx, cy, cr * 0.55, cx, cy, cr);
      grad.addColorStop(0, 'rgba(0,0,0,0)');
      grad.addColorStop(1, 'rgba(0,0,0,0.45)');
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, cr, 0, Math.PI * 2);
      ctx.clip();
      ctx.fillStyle = grad;
      ctx.fillRect(d, 0, S, d);
      ctx.restore();

      // Gold outer rim
      ctx.strokeStyle = 'rgba(212,168,67,0.80)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(cx, cy, cr, 0, Math.PI * 2); ctx.stroke();

      // Crosshair lines (gap in centre so they don't obscure the target)
      const gap = Math.round(cr * 0.28);
      ctx.strokeStyle = 'rgba(212,168,67,0.60)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx - cr + 4, cy);  ctx.lineTo(cx - gap, cy);   // left arm
      ctx.moveTo(cx + gap, cy);     ctx.lineTo(cx + cr - 4, cy); // right arm
      ctx.moveTo(cx, cy - cr + 4);  ctx.lineTo(cx, cy - gap);    // top arm
      ctx.moveTo(cx, cy + gap);     ctx.lineTo(cx, cy + cr - 4); // bottom arm
      ctx.stroke();

      // Centre dot
      ctx.fillStyle = 'rgba(212,168,67,0.70)';
      ctx.beginPath(); ctx.arc(cx, cy, 2, 0, Math.PI * 2); ctx.fill();

      // ── Gold rims on big circles ──
      ctx.strokeStyle = 'rgba(212,168,67,0.65)';
      ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.arc(d / 2,      d / 2, d / 2 - 1.5, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath(); ctx.arc(rx + d / 2, d / 2, d / 2 - 1.5, 0, Math.PI * 2); ctx.stroke();

      // Inner highlight rings
      ctx.strokeStyle = 'rgba(255,220,120,0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(d / 2,      d / 2, d / 2 - 5, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath(); ctx.arc(rx + d / 2, d / 2, d / 2 - 5, 0, Math.PI * 2); ctx.stroke();
    }

    function positionLens(mx, my) {
      const { d, lw, lh } = lensShape();
      const vw = vpW(), vh = vpH();
      const margin = 10;
      // Cursor locked to centre of reticle = (d + S/2, lh/2) in canvas coords
      const lx = Math.max(margin, Math.min(vw - lw - margin, mx - d - S / 2));
      const ly = Math.max(margin, Math.min(vh - lh - margin, my - lh / 2));
      lens.style.left = lx + 'px';
      lens.style.top  = ly + 'px';
    }

    document.addEventListener('mousemove', e => {
      if (!lensEnabled) return;
      draw(e.clientX, e.clientY);
      positionLens(e.clientX, e.clientY);
      if (!lensVisible) { lensVisible = true; lens.style.opacity = '1'; }
    });

    document.addEventListener('mouseleave', () => {
      lensVisible = false;
      if (lens.style.opacity !== '0') lens.style.opacity = '0';
    });
  }

})();
</script>

</body>
</html>
